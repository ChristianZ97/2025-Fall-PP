<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Blocked FW: 資料依賴性視覺化</title>
  <style>
    body {
      font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
      background-color: #f4f7f9;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      user-select: none;
    }

    h2 { color: #37474F; margin-bottom: 5px; }
    p.subtitle { color: #78909C; font-size: 14px; margin-bottom: 20px; }

    /* 佈局容器 */
    .main-layout {
      display: flex;
      gap: 30px;
      align-items: flex-start;
    }

    /* 左側：矩陣 */
    .matrix-wrapper {
      position: relative;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    table { border-collapse: collapse; }
    td {
      width: 40px; height: 40px;
      border: 1px solid #ECEFF1;
      text-align: center;
      font-size: 11px;
      color: #B0BEC5;
      transition: all 0.3s;
      position: relative;
    }

    /* 粗框線區分 Block (B=2) */
    .block-border-right { border-right: 3px solid #546E7A !important; }
    .block-border-bottom { border-bottom: 3px solid #546E7A !important; }

    /* 狀態顏色 */
    .bg-block-active { background-color: #FFF3E0; } /* 當前 Block 底色 */
    .bg-block-done { background-color: #E8F5E9; }   /* 已完成 Block 底色 */
    
    /* Target: 正在計算的點 */
    .cell-target {
      background-color: #FF5252 !important;
      color: white !important;
      font-weight: bold;
      transform: scale(1.1);
      z-index: 10;
      box-shadow: 0 0 8px rgba(255, 82, 82, 0.6);
      border: 2px solid #D32F2F !important;
    }

    /* Source Safe: 來自外部 */
    .cell-src-safe {
      background-color: #E3F2FD !important;
      color: #1976D2 !important;
      border: 2px solid #2196F3 !important;
      font-weight: bold;
      z-index: 5;
    }

    /* Source Hazard: 來自內部 (危險) */
    .cell-src-hazard {
      background-color: #FFEBEE !important;
      color: #C62828 !important;
      border: 2px solid #C62828 !important;
      font-weight: bold;
      z-index: 5;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(198, 40, 40, 0.4); }
      70% { box-shadow: 0 0 0 6px rgba(198, 40, 40, 0); }
      100% { box-shadow: 0 0 0 0 rgba(198, 40, 40, 0); }
    }

    /* SVG 線條層 */
    #svg-layer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 20;
    }
    line { stroke-width: 2; stroke-linecap: round; }
    .line-safe { stroke: #2196F3; stroke-dasharray: 5, 3; animation: dash 20s linear infinite; }
    .line-hazard { stroke: #D32F2F; stroke-width: 3; }

    /* 右側：控制與說明 */
    .panel {
      width: 320px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .control-box {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      text-align: center;
    }

    button {
      background: #263238; color: white;
      border: none; padding: 8px 16px;
      border-radius: 4px; cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #37474F; }
    button:disabled { background: #CFD8DC; cursor: not-allowed; }

    .info-box {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      font-size: 14px;
      line-height: 1.6;
    }

    .tag {
      display: inline-block; padding: 3px 8px; border-radius: 4px;
      font-size: 12px; font-weight: bold; color: white;
      margin-bottom: 10px;
    }
    .tag-p1 { background: #7E57C2; }
    .tag-p2 { background: #FFA726; }
    .tag-p3 { background: #66BB6A; }

    .highlight-text { color: #D32F2F; font-weight: bold; }
    .safe-text { color: #1976D2; font-weight: bold; }

    .k-indicator {
      margin-top: 10px;
      padding: 10px;
      background: #ECEFF1;
      border-radius: 4px;
      font-size: 13px;
      color: #455A64;
    }
  </style>
</head>
<body>

  <h2>Blocked Floyd-Warshall 資料流模擬</h2>
  <p class="subtitle">觀察資料來源是否位於「同一個 Block」內 (V=6, B=2)</p>

  <div class="main-layout">
    <div class="matrix-wrapper">
      <svg id="svg-layer"></svg>
      <table id="grid"></table>
    </div>

    <div class="panel">
      <div class="control-box">
        <div style="margin-bottom:10px; font-weight:bold; color:#546E7A">
          <span id="lblRound">Round: -</span> | <span id="lblStep">Step: -</span>
        </div>
        <button id="btnPrev" disabled>上一步</button>
        <button id="btnNext">下一步</button>
        <button id="btnReset" style="background:#ef5350; margin-left:10px">重置</button>
      </div>

      <div class="info-box">
        <div id="phaseBadge" class="tag tag-p1">準備開始</div>
        <h3 id="phaseTitle" style="margin:0 0 10px 0; font-size:16px;">初始化</h3>
        <div id="descContent">
          點擊「下一步」開始演算法。<br><br>
          <ul style="padding-left:20px; margin:0;">
            <li><b style="color:#FF5252">紅色格</b>：Target (正在更新的點)</li>
            <li><b style="color:#2196F3">藍色格</b>：資料來源 (安全/唯讀)</li>
            <li><b style="color:#D32F2F">紅色閃爍</b>：資料來源 (危險/同Block)</li>
          </ul>
        </div>
        <div class="k-indicator" id="kInfo">
          公式: D[i][j] = min( D[i][j], <br>
          &nbsp;&nbsp;&nbsp;&nbsp;<span id="formulaSrc1">D[i][k]</span> + <span id="formulaSrc2">D[k][j]</span> )
        </div>
      </div>
    </div>
  </div>

<script>
const V = 6;
const B = 2;
const TOTAL_ROUNDS = V / B;

let steps = [];
let currentIdx = -1;

// 產生模擬步驟
function generateSimulation() {
  const s = [];
  
  for (let r = 0; r < TOTAL_ROUNDS; r++) {
    const k_start = r * B; 
    // 我們假設展示 k = k_start (該 block 的第一個 k)
    
    // --- Phase 1: Pivot Block (r, r) ---
    // 選擇 Pivot Block 內的一個點 (r*B+1, r*B+1)
    s.push(createStep(r, 1, r, r, r*B+1, r*B+1, k_start));

    // --- Phase 2: Pivot Row & Pivot Col ---
    // 1. Pivot Row Block (r, next_col)
    let c2 = (r + 1) % TOTAL_ROUNDS;
    s.push(createStep(r, 2, r, c2, r*B, c2*B+1, k_start));
    // 2. Pivot Col Block (next_row, r)
    let r2 = (r + 1) % TOTAL_ROUNDS;
    s.push(createStep(r, 2, r2, r, r2*B+1, r*B, k_start));

    // --- Phase 3: Independent Block (r_next, c_next) ---
    // 選擇一個既不是 pivot row 也不是 pivot col 的 block
    s.push(createStep(r, 3, r2, c2, r2*B+1, c2*B+1, k_start));
  }
  
  s.push({ type: 'finish' });
  return s;
}

function createStep(round, phase, bRow, bCol, i, j, k) {
  // 計算來源
  const src1 = { r: i, c: k }; // D[i][k]
  const src2 = { r: k, c: j }; // D[k][j]
  
  // 判斷 Hazard: Source 是否在當前 Block (bRow, bCol) 內
  const isHazard1 = (Math.floor(src1.r/B) === bRow && Math.floor(src1.c/B) === bCol);
  const isHazard2 = (Math.floor(src2.r/B) === bRow && Math.floor(src2.c/B) === bCol);

  return {
    type: 'step',
    round: round,
    phase: phase,
    block: { r: bRow, c: bCol },
    target: { r: i, c: j },
    k: k,
    src1: src1,
    src2: src2,
    h1: isHazard1,
    h2: isHazard2
  };
}

// DOM 元素
const grid = document.getElementById('grid');
const svg = document.getElementById('svg-layer');
const lblRound = document.getElementById('lblRound');
const lblStep = document.getElementById('lblStep');
const phaseBadge = document.getElementById('phaseBadge');
const phaseTitle = document.getElementById('phaseTitle');
const descContent = document.getElementById('descContent');
const kInfo = document.getElementById('kInfo');
const formulaSrc1 = document.getElementById('formulaSrc1');
const formulaSrc2 = document.getElementById('formulaSrc2');

// 初始化表格
function initGrid() {
  grid.innerHTML = '';
  for (let r = 0; r < V; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < V; c++) {
      const td = document.createElement('td');
      td.id = `c-${r}-${c}`;
      td.textContent = `${r},${c}`;
      if ((c + 1) % B === 0 && c !== V - 1) td.classList.add('block-border-right');
      if ((r + 1) % B === 0 && r !== V - 1) td.classList.add('block-border-bottom');
      tr.appendChild(td);
    }
    grid.appendChild(tr);
  }
}

// 渲染
function render(idx) {
  // 清除舊狀態
  document.querySelectorAll('td').forEach(td => {
    td.className = ''; // reset
    // 補回 border
    const id = td.id.split('-'); 
    const r = parseInt(id[1]), c = parseInt(id[2]);
    if ((c + 1) % B === 0 && c !== V - 1) td.classList.add('block-border-right');
    if ((r + 1) % B === 0 && r !== V - 1) td.classList.add('block-border-bottom');
  });
  svg.innerHTML = '';

  const s = steps[idx];
  if (!s) return;

  if (s.type === 'finish') {
    phaseBadge.className = 'tag';
    phaseBadge.style.background = '#333';
    phaseBadge.textContent = "結束";
    phaseTitle.textContent = "模擬完成";
    descContent.innerHTML = "Phase 3 展示完畢。你可以清楚看到在 Phase 3，<br>所有的資料來源(藍色)都來自 Block 外部，<br>完全不依賴 Block 內部的數值。";
    lblStep.textContent = "Step: End";
    return;
  }

  // 更新文字
  lblRound.textContent = `Round: ${s.round}`;
  lblStep.textContent = `Step: ${idx + 1}/${steps.length-1}`;
  
  // 標示當前 Block 背景
  highlightBlock(s.block.r, s.block.c, 'bg-block-active');

  // 標示 Target
  const tCell = getCell(s.target.r, s.target.c);
  tCell.classList.add('cell-target');

  // 標示 Source 1
  const s1Cell = getCell(s.src1.r, s.src1.c);
  s1Cell.classList.add(s.h1 ? 'cell-src-hazard' : 'cell-src-safe');

  // 標示 Source 2
  const s2Cell = getCell(s.src2.r, s.src2.c);
  s2Cell.classList.add(s.h2 ? 'cell-src-hazard' : 'cell-src-safe');

  // 畫線
  drawLine(tCell, s1Cell, s.h1);
  drawLine(tCell, s2Cell, s.h2);

  // 更新說明面板
  updatePanelInfo(s);
}

function updatePanelInfo(s) {
  kInfo.innerHTML = `Current k = <b>${s.k}</b> (Pivot範圍: ${Math.floor(s.k/B)*B}~${Math.floor(s.k/B)*B+B-1})`;
  
  // Formula highlighting
  formulaSrc1.style.color = s.h1 ? '#D32F2F' : '#1976D2';
  formulaSrc1.style.fontWeight = 'bold';
  formulaSrc1.textContent = `D[${s.src1.r}][${s.src1.c}]`;
  
  formulaSrc2.style.color = s.h2 ? '#D32F2F' : '#1976D2';
  formulaSrc2.style.fontWeight = 'bold';
  formulaSrc2.textContent = `D[${s.src2.r}][${s.src2.c}]`;

  if (s.phase === 1) {
    phaseBadge.className = 'tag tag-p1';
    phaseBadge.textContent = 'Phase 1 (Pivot Block)';
    phaseTitle.textContent = '自我更新 (Dependency)';
    descContent.innerHTML = `
      Target 在 Pivot Block 內。<br>
      k 也在這個 Block 內。<br>
      <span class="highlight-text">兩條線都指向自己 Block 內部。</span><br>
      執行緒之間有強烈相依性 -> <b>需要同步</b>。
    `;
  } else if (s.phase === 2) {
    phaseBadge.className = 'tag tag-p2';
    phaseBadge.textContent = 'Phase 2 (Pivot Row/Col)';
    phaseTitle.textContent = '部分依賴 (Dependency)';
    descContent.innerHTML = `
      Target 在 Pivot Row 或 Col 上。<br>
      <span class="safe-text">一條線指向外部 (Phase 1 完成區)。</span><br>
      <span class="highlight-text">另一條線指向自己 Block 內部。</span><br>
      讀到了正在修改的區域 -> <b>需要同步</b>。
    `;
  } else {
    phaseBadge.className = 'tag tag-p3';
    phaseBadge.textContent = 'Phase 3 (Independent)';
    phaseTitle.textContent = '完全獨立 (Safe)';
    descContent.innerHTML = `
      Target 在一般 Block。<br>
      k 指向 Pivot Row 和 Pivot Col。<br>
      <span class="safe-text">兩條線都指向外部 (Phase 2 完成區)。</span><br>
      完全不讀取自己 Block 內的資料。<br>
      <b>安全！可以把 k loop 移進 kernel！</b>
    `;
  }
}

function highlightBlock(br, bc, cls) {
  for(let r=br*B; r<(br+1)*B; r++) {
    for(let c=bc*B; c<(bc+1)*B; c++) {
      getCell(r, c).classList.add(cls);
    }
  }
}

function getCell(r, c) {
  return document.getElementById(`c-${r}-${c}`);
}

function drawLine(el1, el2, isHazard) {
  if(!el1 || !el2) return;
  const r1 = el1.getBoundingClientRect();
  const r2 = el2.getBoundingClientRect();
  const root = grid.getBoundingClientRect();

  const x1 = r1.left + r1.width/2 - root.left;
  const y1 = r1.top + r1.height/2 - root.top;
  const x2 = r2.left + r2.width/2 - root.left;
  const y2 = r2.top + r2.height/2 - root.top;

  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', x1); line.setAttribute('y1', y1);
  line.setAttribute('x2', x2); line.setAttribute('y2', y2);
  line.classList.add(isHazard ? 'line-hazard' : 'line-safe');
  
  // 箭頭marker可選，這裡省略保持簡潔
  svg.appendChild(line);
}

// 按鈕事件
document.getElementById('btnNext').onclick = () => {
  if (currentIdx < steps.length - 1) {
    currentIdx++;
    render(currentIdx);
    document.getElementById('btnPrev').disabled = false;
  }
};
document.getElementById('btnPrev').onclick = () => {
  if (currentIdx > 0) {
    currentIdx--;
    render(currentIdx);
  } else {
    document.getElementById('btnPrev').disabled = true;
  }
};
document.getElementById('btnReset').onclick = () => {
  currentIdx = 0;
  render(0);
  document.getElementById('btnPrev').disabled = true;
};

// 啟動
initGrid();
steps = generateSimulation();
currentIdx = 0;
render(0);

</script>
</body>
</html>
